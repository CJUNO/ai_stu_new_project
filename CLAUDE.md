# CLAUDE.md

이 파일은 Claude Code (claude.ai/code)가 이 저장소에서 작업할 때 참고하는 가이드입니다.

## 프로젝트 개요

Algo-Race 5는 5가지 정렬 알고리즘이 서로 경주하는 모습을 실시간으로 시각화하는 웹 애플리케이션입니다. 백엔드(FastAPI)가 단계별 정렬 명령을 생성하고, 프론트엔드(React)가 이 단계들을 애니메이션 레이스 트랙으로 재생하여 사용자가 시간 복잡도 차이(O(N²) vs O(N log N))를 직관적으로 체험할 수 있습니다.

**핵심 설계 철학: 서버 주도 UI (Server-Driven UI)**
- 프론트엔드는 정렬 로직이 전혀 없습니다
- 백엔드의 명령을 실행하는 "플레이어" 역할만 수행합니다
- 모든 알고리즘 지능은 백엔드에 존재합니다

## 개발 명령어

### 백엔드 (FastAPI)
```bash
# backend/ 디렉토리에서 실행
pip install -r requirements.txt
uvicorn main:app --reload --port 8000

# API 테스트: http://localhost:8000/docs
```

### 프론트엔드 (React + Vite)
```bash
# frontend/ 디렉토리에서 실행
npm install
npm run dev  # 개발 서버 (포트 5173)
npm run build  # 프로덕션 빌드
```

참고: 프로젝트 명세에서 "server: npm으로 실행"으로 지정되어 있습니다.

## 아키텍처

### 백엔드 구조 (`backend/`)

**algorithms.py** - 핵심 정렬 알고리즘 구현
- 5가지 알고리즘 포함: 버블 정렬, 선택 정렬, 삽입 정렬, 힙 정렬, 퀵 정렬
- 각 알고리즘은 반드시 "단계(steps)" 리스트를 반환해야 합니다 (정렬된 배열만 반환하면 안 됨)
- 단계(Step) 형식:
  ```python
  {
    "type": "compare" | "swap" | "overwrite",
    "indices": [i, j],  # 관련된 배열 인덱스
    "pivot": index  # 선택사항, 퀵 정렬 시각화용
  }
  ```

**main.py** - FastAPI 엔드포인트
- `POST /api/race` - 경주 데이터 생성
  - 요청: `{"size": 50}`
  - 응답: `{"initial_data": [...], "results": {"Bubble Sort": [steps...], ...}}`
- 공정한 비교를 위해 5개 알고리즘 모두 동일한 초기 랜덤 배열을 받습니다

**models.py** - Pydantic 요청/응답 검증 스키마

### 프론트엔드 구조 (`frontend/src/`)

**components/SortChart.jsx** - 개별 알고리즘 플레이어
- Props:
  - `name`: 알고리즘 이름
  - `initialData`: 시작 배열
  - `steps`: 백엔드에서 받은 단계 객체 배열
  - `start`: 애니메이션 시작 트리거 (Boolean)
  - `onFinish`: 정렬 완료 시 콜백 함수
- 애니메이션 루프 (10-50ms 간격):
  - 현재 단계를 읽습니다
  - "swap"인 경우: 로컬 배열 상태 업데이트 + 초록색 하이라이트
  - "compare"인 경우: 빨간색 하이라이트만 (배열 변경 없음)
  - 단계가 모두 끝나면 `onFinish(name)` 호출
- 막대는 div로 렌더링되며 `height: ${value}%` 사용

**components/RaceTrack.jsx** - 메인 컨테이너
- 반응형 그리드(2x3 또는 유사)로 5개의 SortChart 인스턴스 관리
- 완료 순서 추적: `finishedOrder` state 배열
- 완료 순서에 따라 메달(🥇🥈🥉) 표시
- "START RACE" 버튼 포함:
  1. `POST /api/race` 호출
  2. 모든 차트에 데이터 분배
  3. `start=true` 설정하여 애니메이션 트리거

**components/WinnerBadge.jsx** - 순위 표시 컴포넌트

### 데이터 흐름

1. 사용자가 "START RACE" 클릭
2. 프론트엔드가 배열 크기와 함께 `POST /api/race` 호출
3. 백엔드:
   - 랜덤 배열 생성
   - 5개 알고리즘 모두 실행
   - 모든 비교/교환을 단계로 기록
   - 초기 배열 + 5개의 단계 리스트 반환
4. 프론트엔드:
   - 동일한 `initialData`로 5개의 SortChart 컴포넌트 초기화
   - 각 차트가 독립적으로 자신의 `steps` 배열 재생
   - 차트들이 서로 다른 시간에 완료 (버블이 가장 느림, 퀵이 가장 빠름)
   - 먼저 완료한 3개가 메달 획득

## 스타일링 요구사항

**테마: 사이버펑크 다크 모드**
- 배경: `bg-gray-900` (매우 어두운 색)
- 기본 막대: `bg-cyan-400` (네온 시안)
- 비교 상태: `bg-rose-500` (네온 레드)
- 교환 상태: `bg-emerald-400` (네온 그린)
- 폰트: `font-mono` (개발자 느낌)
- TailwindCSS만 사용 (별도 차트 라이브러리 사용 안 함)

## 주요 구현 참고사항

### 백엔드
- 정렬 알고리즘 구현 시, 각 비교/교환 작업마다 반드시 단계를 수집해야 합니다
- 단계 수가 이론적 복잡도와 일치하는지 테스트하세요 (버블은 ~N² 단계, 퀵은 ~N log N 단계)
- `/docs`의 Swagger UI를 사용하여 API 응답 확인

### 프론트엔드
- 애니메이션 속도가 중요합니다 - 너무 빠르면 차이가 안 보이고, 너무 느리면 지루합니다
- 인터벌 타이밍 실험 (10-50ms 권장)
- `start` prop은 5개의 경주를 동시에 시작하도록 동기화합니다
- SortChart의 로컬 state는 initialData의 복사본이어야 합니다 (props를 직접 수정하지 마세요)
- 하이라이트 지속 시간은 짧지만 가시적이어야 합니다

### 테스트 전략
1. 백엔드: 각 알고리즘의 단계 생성에 대한 유닛 테스트
2. API: FastAPI의 `/docs`를 사용하여 JSON 구조 검증
3. 프론트엔드: RaceTrack에 통합하기 전에 먼저 SortChart를 독립적으로 구축
4. 통합: 단계 재생 디버깅을 위해 작은 배열(size=10)로 먼저 테스트

## 흔한 실수들

- **프론트엔드에 정렬 로직을 구현하지 마세요** - 단계만 재생합니다
- **props를 직접 수정하지 마세요** - SortChart는 initialData를 로컬 state로 복제해야 합니다
- **인터벌 정리를 잊지 마세요** - 애니메이션이 정리되지 않으면 메모리 누수 발생
- **단계 타입을 혼동하지 마세요** - "compare"는 배열을 수정하지 않고, "swap"은 반드시 배열을 수정해야 합니다

## 알고리즘 시간 복잡도 참고

| 알고리즘        | 시간 복잡도      | 예상 동작                  |
|---------------|-----------------|---------------------------|
| 버블 정렬      | O(N²)          | 가장 느림, 많은 교환        |
| 선택 정렬      | O(N²)          | 중간, 왼쪽에서 오른쪽으로   |
| 삽입 정렬      | O(N²)          | 데이터 순서에 따라 다름     |
| 힙 정렬        | O(N log N)     | 빠름, 많은 교환            |
| 퀵 정렬        | O(N log N)     | 가장 빠름 (평균)           |

시각적 "경주"는 O(N²)와 O(N log N) 알고리즘 간의 성능 차이를 명확히 보여줘야 합니다.
